---
title: "Bulk RNA-seq data analysis - TF enrichment CL075 vs Ctrl"
output:
  
  pdf_document:
    keep_md: true
    toc: true
    toc_depth: 3
    number_sections: true
    df_print: kable
  html_document:
    keep_md: true
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
always_allow_html: true
header-includes:
  - \hypersetup{colorlinks=true, linkcolor=blue}
---

```{r setup, include=FALSE}
httr::set_config(httr::config(ssl_verifypeer = FALSE))
knitr::opts_chunk$set(warning = F, message = F)
knitr::opts_chunk$set(dpi=300,fig.width=7)

# require(Hmisc)
# hidingTOC()
```

```{r packages, warning=FALSE, message=FALSE}
# BiocManager::install("edgeR")
# BiocManager::install("GO.db")
# BiocManager::install("org.Hs.eg.db")
# install.packages("remotes")
# remotes::install_github("jmw86069/multienrichjam",dependencies=TRUE);
# BiocManager::install("pathview")
# BiocManager::install("cbiagii/CeTF")
library(CeTF)
#library(airway)
#library(kableExtra)
#library(knitr)
library(edgeR)
library(tidyverse)
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggnetwork)
library(network)
library(GGally)
library(GO.db)
library(org.Hs.eg.db)
library(biomaRt)
library(pheatmap)
library(RColorBrewer)
library(ComplexHeatmap)
library(wesanderson)
library(topGO)
library(EnsDb.Hsapiens.v79)
library(statmod)
library(patchwork)
library(multienrichjam)
library(enrichplot)
library(DOSE)
library(clusterProfiler)
library(GOSemSim)
library(ggupset)
library(circlize)
library(httr)
library(jsonlite)
library(rmarkdown)
library(WGCNA)
library(DESeq2)
#library(pathview)
```

```{r vis_fns, echo = F}

my_histPlot <- function(mat) {
    if (!is.data.frame(mat) & !is.matrix(mat)) {
        stop("input must be a dataframe or a matrix")
    }
    
    cc <- clustCoef(mat)
    
    df1 <- data.frame(clustcoef = cc)
    pt1 <- ggplot(df1, aes(.data[["clustcoef"]])) + 
      geom_histogram(breaks = seq(0, 0.6, by = 0.05), 
                     col = "black", fill = "#1F3552") + 
      ggtitle("Connectivity Distribution") + 
      xlab("Proportion of Connections") + 
      ylab("Number of Genes") + 
      scale_y_continuous(expand = c(0,0)) + 
      scale_x_continuous(labels = function(x) paste0(x * 100, "%")) + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
        panel.grid.major = element_line(colour = "#d3d3d3"), 
        panel.grid.minor = element_blank(), 
        panel.border = element_blank(), 
        panel.background = element_blank(), 
        plot.title = element_text(size = 12), 
        axis.text.x = element_text(size = 8), 
        axis.text.y = element_text(size = 8))
    
    
    df2 <- data.frame(clustcoef = cc * length(cc))
    pt2 <- ggplot(df2, aes(x = .data[["clustcoef"]])) + 
      geom_step(stat = "ecdf", col = "red", size = 1) + 
      scale_y_continuous(labels = function(x) paste0(x * 100, "%")) + 
      ggtitle("Connectivity Distribution") + 
      xlab("Number of Genes") + 
      ylab("Cumulative Proportion") + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
            panel.grid.major = element_line(colour = "#d3d3d3"), 
            panel.grid.minor = element_blank(), 
            panel.border = element_blank(), 
            panel.background = element_blank(), 
            plot.title = element_text(size = 12), 
            axis.text.x = element_text(size = 8), 
            axis.text.y = element_text(size = 8))
    
    return(ggarrange(pt1, pt2, ncol = 2))
}

my_densityPlot <- function(mat1, mat2, threshold = 0.5) {
    if (!is.data.frame(mat1) & !is.matrix(mat1)) {
        stop("mat1 must be a dataframe or a matrix")
    }
    if (!is.data.frame(mat2) & !is.matrix(mat2)) {
        stop("mat2 must be a dataframe or a matrix")
    }
    
    df1 <- data.frame(corr = mat1[upper.tri(mat1)])
    df2 <- data.frame(corr = mat1[upper.tri(mat1) & !is.na(mat1)], sig = "All")
    df3 <- data.frame(corr = mat2[intersect(which(as.single(mat2) != 0), 
        which(upper.tri(mat1)))], sig = "PCIT Significant")
    df4 <- data.frame(corr = mat1[intersect(which(abs(mat1) > threshold), 
        which(upper.tri(mat1)))], sig = paste0("abs. cor. > ", threshold))
    
    dn <- density(df1[["corr"]])
    pt1 <- ggplot(df1, aes(x = .data[["corr"]])) + 
      geom_density(colour = "black", fill = "#a0b8d6", size = 1) + 
      scale_x_continuous(name = "Correlation Coefficient", 
                         breaks = seq(-1, 1, 0.2), limits = c(-1, 1)) + 
      scale_y_continuous(name = "Density", 
                         expand = c(0, 0), 
                         limits = c(0, range(dn[["y"]] + 0.1)[2])) + 
      ggtitle("Density Plot of Raw Correlation Coefficients") + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
        panel.grid.major = element_line(colour = "#d3d3d3"), 
        panel.grid.minor = element_blank(), 
        panel.border = element_blank(), 
        panel.background = element_blank(), 
        plot.title = element_text(size = 12), 
        axis.text.x = element_text(size = 8), 
        axis.text.y = element_text(size = 8)) + 
        geom_vline(xintercept = mean(df1[["corr"]]), 
                   size = 1, colour = "#FF3721", 
            linetype = "dashed")
    
    df <- rbind(df2, df3)
    pt2 <- ggplot(df, aes_string("corr")) + 
      geom_histogram(data = subset(df, df[["sig"]] == "All"), 
                     aes(fill = subset(df, df[["sig"]] == "All")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), col = "black") + 
      geom_histogram(data = subset(df, df[["sig"]] == "PCIT Significant"), 
                     aes(fill = subset(df, df[["sig"]] == "PCIT Significant")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), 
        col = "black") + 
      scale_fill_manual(name = "", values = c("gray", "black"), 
                        labels = c("All", "PCIT Significant")) + 
      ggtitle("Density Distribution of Correlation Coefficients") + 
      xlab("Correlation Coefficient") + 
      ylab("Frequency") + 
      scale_y_continuous(expand = c(0, 0)) + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
        panel.grid.major = element_line(colour = "#d3d3d3"), 
        panel.grid.minor = element_blank(), 
        panel.border = element_blank(), 
        panel.background = element_blank(), 
        plot.title = element_text(size = 12), 
        axis.text.x = element_text(size = 8), 
        axis.text.y = element_text(size = 8), 
        legend.position = "top")
    
    df <- rbind(df2, df3, df4)
    pt3 <- ggplot(df, aes_string("corr")) + 
      geom_histogram(data = subset(df, df[["sig"]] == "All"), 
                     aes(fill = subset(df, df[["sig"]] == "All")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), col = "black") + 
      geom_histogram(data = subset(df, df[["sig"]] == paste0("abs. cor. > ", threshold)), 
                     aes(fill = subset(df, df[["sig"]] == paste0("abs. cor. > ", threshold))[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), col = "black") + 
      geom_histogram(data = subset(df, df[["sig"]] == "PCIT Significant"), 
                     aes(fill = subset(df, df[["sig"]] == "PCIT Significant")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), col = "black") + 
      scale_fill_manual(name = "", values = c("red","gray", "black"), 
                        labels = c(paste0("abs. cor. > ", threshold), 
                                   "All", "PCIT Significant")) + 
      xlab("Correlation Coefficient") + 
      ylab("Frequency") + 
      scale_y_continuous(expand = c(0, 0)) + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
            panel.grid.major = element_line(colour = "#d3d3d3"), 
            panel.grid.minor = element_blank(), 
            panel.border = element_blank(), 
            panel.background = element_blank(), 
            plot.title = element_text(size = 12), 
            axis.text.x = element_text(size = 8), 
            axis.text.y = element_text(size = 8), 
            legend.position = "top")
    
    df <- rbind(df2, df3, df4)
    pt4 <- ggplot(df, aes_string("corr")) + 
      geom_histogram(data = subset(df, df[["sig"]] == "All"), 
                     aes(fill = subset(df, df[["sig"]] == "All")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), col = "black", alpha = 0.8) + 
      geom_histogram(data = subset(df, df[["sig"]] == "PCIT Significant"), 
                     aes(fill = subset(df, df[["sig"]] == 
                                         "PCIT Significant")[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), 
                     col = "black", alpha = 0.9) + 
      geom_histogram(data = subset(df, df[["sig"]] == paste0("abs. cor. > ", threshold)), 
                     aes(fill = subset(df, df[["sig"]] == paste0("abs. cor. > ", threshold))[["sig"]]), 
                     breaks = seq(-1, 1, by = 0.05), 
                     col = "black", alpha = 0.8) + 
      scale_fill_manual(name = "", values = c("gray10", "gray", "darkred"), 
                        labels = c(paste0("abs. cor. > ", threshold), 
                                   "All", "PCIT Significant")) + 
      xlab("Correlation Coefficient") + 
      ylab("Frequency") + 
      scale_y_continuous(expand = c(0, 0)) + 
      theme_bw() + 
      theme(axis.line = element_line(size = 1, colour = "black"), 
            panel.grid.major = element_line(colour = "#d3d3d3"), 
            panel.grid.minor = element_blank(), 
            panel.border = element_blank(), 
            panel.background = element_blank(), 
            plot.title = element_text(size = 12), 
            axis.text.x = element_text(size = 8), 
            axis.text.y = element_text(size = 8), 
            legend.position = "top")
    
    pt <- ggarrange(plotlist = list(pt1, pt2, pt3, pt4), widths = c(2, 
        2))
    
    return(pt)
}

my_netConditionsPlot <- function(x) {
    if (!is(x, "CeTF")) {
        stop("the input must be a CeTF class object")
    }
    
    TFs <- NetworkData(x, "keytfs")[["TF"]]
    mainTFs <- NetworkData(x, "keytfs")[order(NetworkData(x, "keytfs")[["freq.diff"]], 
        decreasing = TRUE), ]
    
    # cond1
    nt1 <- network(NetworkData(x, "network1"), directed = FALSE)
    genes1 <- unique(c(as.character(NetworkData(x, "network1")[["gene1"]]), 
        as.character(NetworkData(x, "network1")[["gene2"]])))
    gns1 <- setdiff(genes1, TFs)
    
    map <- data.frame(pattern = c(TFs, gns1), sb = c(rep("TFs", length(TFs)), 
        rep("Gene", length(gns1))), stringsAsFactors = FALSE)
    og <- data.frame(singleValue = network.vertex.names(nt1), stringsAsFactors = FALSE)
    cvt <- vapply(map$pattern, grepl, logical(nrow(og)), og$singleValue)
    og$Category <- map$sb[max.col(cvt, "last")]
    x1 <- factor(og$Category)
    
    nt1 %v% "color" <- as.character(x1)
    
    if (length(levels(x1)) == 1) {
        y = "Set1"
    } else {
        y <- c("#449a7dff", "#e48e1aff")
        names(y) = levels(x1)
    }
    
    labels <- c(as.character(head(mainTFs, 2)[, "TF"]), as.character(tail(mainTFs, 
        2)[, "TF"]))
    pt1 <- ggnet2(nt1, color = "color", color.legend = "", palette = y, 
        edge.size = 0.5, edge.color = "gray70", label.size = 2.5, alpha = 0.75, 
        size = "degree", edge.alpha = 0.5, label = labels, legend.position = "bottom") + 
        coord_equal() + guides(size = FALSE) + ggtitle(paste("Network:", 
        gsub("freq.", "", colnames(NetworkData(x, "keytfs"))[5]))) + theme(panel.background = element_rect(fill = "white", 
        colour = "grey50"))
    
    # cond2
    nt2 <- network(NetworkData(x, "network2"), directed = FALSE)
    genes2 <- unique(c(as.character(NetworkData(x, "network2")[["gene1"]]), 
        as.character(NetworkData(x, "network2")[["gene2"]])))
    gns2 <- setdiff(genes2, TFs)
    
    map <- data.frame(pattern = c(TFs, gns2), sb = c(rep("TFs", length(TFs)), 
        rep("Gene", length(gns2))), stringsAsFactors = FALSE)
    og <- data.frame(singleValue = network.vertex.names(nt2), stringsAsFactors = FALSE)
    cvt <- vapply(map$pattern, grepl, logical(nrow(og)), og$singleValue)
    og$Category <- map$sb[max.col(cvt, "last")]
    x2 <- factor(og$Category)
    
    nt2 %v% "color" <- as.character(x2)
    
    if (length(levels(x1)) == 1) {
        y = "Set1"
    } else {
        y <- c("#449a7dff", "#e48e1aff")
        names(y) = levels(x2)
    }
    
    labels <- c(as.character(head(mainTFs, 2)[, "TF"]), as.character(tail(mainTFs, 
        2)[, "TF"]))
    pt2 <- ggnet2(nt2, color = "color", color.legend = "", palette = y, 
        edge.size = 0.5, edge.color = "gray70", label.size = 2.5, alpha = 0.75, 
        size = "degree", edge.alpha = 0.5, label = labels, legend.position = "bottom") + 
        coord_equal() + guides(size = FALSE) + ggtitle(paste("Network:", 
        gsub("freq.", "", colnames(NetworkData(x, "keytfs"))[6]))) + theme(panel.background = element_rect(fill = "white", 
        colour = "grey50"))
    
    return(ggarrange(pt1, pt2, ncol = 2, common.legend = TRUE, legend = "bottom"))
}

my_netGOTFPlot <- function(netCond, resultsGO, netGO, anno, groupBy = "pathways", 
    TFs = NULL, genes = NULL, keyTFs = NULL, size = 2, type = NULL) {
    if (groupBy == "TFs" & is.null(TFs)) {
        stop("for groupBy = TFs you must input some TFs")
    }
    if (groupBy == "genes" & is.null(genes)) {
        stop("for groupBy = genes you must input some genes")
    }
    if (type == "Integrated" & is.null(keyTFs)) {
        stop("this argument must be a character of ketTFs outputed from runAnalysis function")
    }
    if (is.null(type)) {
        stop("this argument must be one of options: GO or all")
    }
   if (type == "GO") 
     {
     if (groupBy == "TFs") {
            tmp1 <- apply(resultsGO, 1, function(x) {
                gns <- as.character(subset(netGO, netGO[["gene1"]] == as.character(x[["ID"]]))[, 
                  "gene2"])
                tmp1 <- data.frame(genes = gns)
                tmp1[["pathway"]] <- as.character(x[["ID"]])
                return(tmp1)
            })
            tmp1 <- do.call(rbind, tmp1)
            
            if (length(which(TFs %in% as.character(tmp1[["genes"]]))) == 
                0) {
                stop("there isn't any TF passed as input in the groupGO analysis: select others TFs")
            }
            
            tmp2 <- NULL
            for (i in seq_len(length(TFs))) {
                t1 <- subset(tmp1, tmp1[["genes"]] == TFs[i])
                if (nrow(t1) != 0) {
                  t2 <- subset(netGO, netGO[["gene1"]] %in% t1[["pathway"]])
                  t2[["TF"]] <- TFs[i]
                  tmp2 <- rbind(tmp2, t2)
                } else {
                  next
                }
            }
            
            anno <- rbind(anno, data.frame(genes = unique(as.character(tmp2[["gene1"]])), 
                class = "pathway"))
            
            # adapted fortify function
            allnodes <- expand.grid(unique(anno[["genes"]]), unique(tmp2[["TF"]]), 
                stringsAsFactors = FALSE)
            node.data.expanded <- merge(allnodes, anno, by.x = "Var1", 
                by.y = "genes")
            tab <- merge(tmp2, node.data.expanded, by.x = c("gene1", "TF"), 
                by.y = c("Var1", "Var2"), all = TRUE)
            
            tab1 <- na.omit(tab)
            tab1 <- unique(tab1)
            
            em.1 <- lapply(unique(tab1[["TF"]]), function(x) subset(tab1, 
                TF == x)[, c(1, 3)])
            em.TF <- lapply(em.1, network, directed = FALSE)
            em.tmp <- lapply(unique(tab[["TF"]]), function(x) subset(tab, 
                TF == x))
            
            for (i in seq_along(em.TF)) {
                set.edge.attribute(em.TF[[i]], "TF", em.tmp[[i]][["TF"]])
                
                df <- unique(data.frame(genes = as.character(em.tmp[[i]][["gene1"]]), 
                  class = as.character(em.tmp[[i]][["class"]]), stringsAsFactors = FALSE))
                var1 <- df[["class"]]
                names(var1) <- df[["genes"]]
                em.TF[[i]] %v% "class" <- var1[network.vertex.names(em.TF[[i]])]
            }
            
            g <- list()
            for (i in seq_along(em.TF)) {
                g[[i]] <- ggplot(ggnetwork(em.TF[[i]], arrow.gap = 0.02, 
                  by = "TF", layout = "fruchtermanreingold"), aes(x, y, 
                  xend = xend, yend = yend)) + geom_edges(aes(color = class), 
                  alpha = 0.5, curvature = 0.05, color = "gray55") + geom_nodes(aes(color = class), 
                  size = 3, show.legend = TRUE, alpha = 0.7) + geom_nodetext(aes(label = vertex.names), 
                  size = 2) + scale_color_brewer("Type", palette = "Set1") + 
                  facet_wrap(~TF) + theme_facet(legend.position = "bottom") +
                  theme(strip.background =element_rect(fill="aliceblue", colour = "skyblue"))
            }
            
            pt <- ggarrange(plotlist = g, ncol = 2, common.legend = TRUE, legend = "bottom")
            
            out <- list(plot = pt, tab = suppressWarnings(split(tab, f = tab[["TF"]])))
      } else if (groupBy == "pathways") {
            tmp <- apply(resultsGO, 1, function(x) {
                gns <- as.character(subset(netGO, netGO[["gene1"]] == as.character(x[["ID"]]))[, 
                  "gene2"])
                tmp1 <- netCond[which(netCond[["gene1"]] %in% gns & netCond[["gene2"]] %in% 
                  gns), ]
                if (nrow(tmp1) != 0) {
                  tmp1[["pathway"]] <- as.character(x[["ID"]])
                }
                return(tmp1)
            })
            tmp <- do.call(rbind, tmp)
            
            # adapted fortify function
            allnodes <- expand.grid(unique(anno[["genes"]]), unique(tmp[["pathway"]]), 
                stringsAsFactors = FALSE)
            node.data.expanded <- merge(allnodes, anno, by.x = "Var1", 
                by.y = "genes")
            tab <- merge(tmp, node.data.expanded, by.x = c("gene1", "pathway"), 
                by.y = c("Var1", "Var2"), all = TRUE)
            
            tab1 <- na.omit(tab)
            tab1 <- unique(tab1)
            
            em.path <- lapply(unique(tab1[["pathway"]]), function(x) subset(tab1, 
                pathway == x)[, c(1, 3)])
            
            del <- NULL
            for (z in seq_along(em.path)) {
                if (nrow(em.path[[z]]) != 1 & (length(unique(as.character(em.path[[z]][[1]]))) == 
                  1 | length(unique(as.character(em.path[[z]][[2]]))) == 
                  1)) {
                  del <- rbind(del, z)
                }
            }
            
            if (!is.null(del)) {
                em.path <- em.path[-del[[1]]]
            }
            
            em.pathway <- lapply(em.path, network, directed = FALSE)
            em.tmp <- lapply(unique(tab[["pathway"]]), function(x) subset(tab, 
                pathway == x))
            
            for (i in seq_along(em.pathway)) {
                set.edge.attribute(em.pathway[[i]], "pathway", em.tmp[[i]][["pathway"]])
                
                df <- unique(data.frame(genes = as.character(em.tmp[[i]][["gene1"]]), 
                  class = as.character(em.tmp[[i]][["class"]]), stringsAsFactors = FALSE))
                var1 <- df[["class"]]
                names(var1) <- df[["genes"]]
                em.pathway[[i]] %v% "class" <- var1[network.vertex.names(em.pathway[[i]])]
            }
            
            g <- list()
            for (i in seq_along(em.pathway)) {
                g[[i]] <- ggplot(ggnetwork(em.pathway[[i]], arrow.gap = 0.02, 
                  by = "pathway", layout = "fruchtermanreingold"), aes(x, 
                  y, xend = xend, yend = yend)) + geom_edges(aes(color = class), 
                  alpha = 0.5, curvature = 0.05, color = "gray55") + geom_nodes(aes(color = class), 
                  size = 3, show.legend = TRUE, alpha = 0.7) + geom_nodetext(aes(label = vertex.names), 
                  size = 2) + scale_color_brewer("Type", palette = "Set1") + 
                  facet_wrap(~pathway) + theme_facet(legend.position = "bottom")+
                  theme(strip.background =element_rect(fill="aliceblue", colour = "skyblue"))
            }
            
            pt <- ggarrange(plotlist = g, ncol = 2, common.legend = TRUE, legend = "bottom")
            
            out <- list(plot = pt, tab = suppressWarnings(split(tab1, f = tab[["pathway"]])))
      }} else if (type == "Integrated") {
        network <- rbind(netCond, netGO)
        net <- network(network, directed = FALSE)
        
        values <- unique(c(as.character(network[["gene1"]]), as.character(network[["gene2"]])))
        pathways <- unique(as.character(netGO[["gene1"]]))
        
        if (is.character(keyTFs)) {
            TFs <- as.character(keyTFs)
        } else {
            TFs <- as.character(keyTFs[["TF"]])
        }
        gns <- setdiff(values, c(TFs, pathways))
        
        map <- data.frame(pattern = c(TFs, gns, pathways), sb = c(rep("TFs", 
            length(TFs)), rep("Gene", length(gns)), rep("GO", length(pathways))), 
            stringsAsFactors = FALSE)
        og <- data.frame(singleValue = network.vertex.names(net), stringsAsFactors = FALSE)
        cvt <- vapply(map[["pattern"]], grepl, logical(nrow(og)), og[["singleValue"]])
        og[["Category"]] <- map[["sb"]][max.col(cvt, "last")]
        x <- factor(og[["Category"]])
        
        net %v% "color" <- net %v% "class" <- as.character(x)
        
        pt <- ggplot(ggnetwork(net, by = "color", layout = "spring"), aes(x, 
            y, xend = xend, yend = yend)) + geom_edges(aes(color = class), 
            alpha = 0.5, curvature = 0.05, color = "gray55") + geom_nodes(aes(color = class), 
            size = 3, show.legend = TRUE,alpha = 0.7) + geom_nodetext(aes(label = vertex.names), 
            size = 2) + scale_color_brewer("Type", palette = "Set1") + 
            theme_facet(legend.position = "bottom") +
            theme(strip.background =element_rect(fill="aliceblue", colour = "skyblue"))
        
        out <- list(plot = pt, tab = network)
    }
    return(out)
}

my_heatPlot <- function(res, diff, showCategory = 10, font_size = 6) {
    if (missing(res)) {
        stop("res must be a dataframe with enrichment results")
    }
    if (missing(diff)) {
        stop("res must be a dataframe with differential expression values")
    }
    if (showCategory == 1) {
        stop("showCategory must be greater than 1")
    }
    
    res <- head(res, showCategory)
    
    pathways <- res[["Description"]]
    genes <- sort(unique(unlist(strsplit(res[["geneID"]], "/"))))
    
    mat <- matrix(0, nrow = length(pathways), ncol = length(genes))
    rownames(mat) <- pathways
    colnames(mat) <- genes
    
    for (i in seq_along(pathways)) {
        gns <- sort(unique(unlist(strsplit(res[i, "geneID"], "/"))))
        mat[i, which(colnames(mat) %in% gns)] <- diff[gns, 3]
    }
    
    is_sig = res[["qvalue"]] < 0.05
    pch = rep("*", length(res[["qvalue"]]))
    pch[!is_sig] <- NA
    pvalue_col_fun <- colorRamp2(c(0, 1, 2), c("darkgreen", "white", "darkred"))
    col_funs = colorRamp2(c(-1, 0, 1), c("salmon", "navy", "darkolivegreen"))
    
    clust1 <- hclust(dist(mat))
    clust2 <- hclust(dist(t(mat)))
    
    mat[mat == 0] <- NA
    cn = colnames(mat)
    
    breaks <- seq(-4, 4, by = 0.1)
    ht <- Heatmap(mat,
                  col = col_funs,
                  show_column_names = FALSE, 
                  bottom_annotation = 
                    HeatmapAnnotation(text = 
                                        anno_text(cn, rot = 90, 
                                                  location = unit(1, "npc"),
                                                  just = "right",
                                                  gp = gpar(fontsize = 5.5)), 
        annotation_height = max_text_width(cn)), cluster_rows = clust1, 
        cluster_columns = clust2, rect_gp = gpar(col = "white"), 
        heatmap_legend_param = list(nrow = 1, 
            title = "Diff"), show_column_dend = FALSE, show_row_dend = FALSE, 
        row_names_gp = gpar(fontsize = 8),
        width = ncol(mat)*unit(2, "mm"))
    
    gR <- c()
    for(i in 1:nrow(res))
    {
      gR1 <- as.numeric(strsplit(res$GeneRatio[i], split = "/")[[1]][1])
      gR2 <- as.numeric(strsplit(res$GeneRatio[i], split = "/")[[1]][2])
      gR[i] <- gR1/gR2
    }
    res$gR <- gR
    ann1 <- rowAnnotation(GeneRatio = anno_barplot(res[["gR"]], 
        width = unit(2.5, "cm"), axis_param = list(direction = "reverse")),
        gp = gpar(fontsize = 4))
    ann2 <- rowAnnotation(FDR = anno_simple(-log10(res[["qvalue"]]), 
                                            col = pvalue_col_fun, 
        pch = pch),
        gp = gpar(fontsize = 4))
    
    total <- ann1 + ann2 + ht
    
    lgd_pvalue = Legend(title = "FDR", col_fun = pvalue_col_fun, at = c(0, 
        1, 2), labels = c("0.1", "0.01", "0.001"), title_gp = gpar(fontsize = 8))
    lgd_sig = Legend(pch = "*", type = "points", labels = "< 0.05", title_gp = gpar(fontsize = 6))
    
    return(draw(total, annotation_legend_list = list(lgd_pvalue, lgd_sig), 
        merge_legends = TRUE, heatmap_legend_side = "right"))
}

my_enrichPlot <- function(res, showCategory = 10, type = "circle") {
    if (missing(res)) {
        stop("res must be a dataframe with enrichment results")
    }
    if (showCategory == 1) {
        stop("showCategory must be greater than 1")
    }
    
    res <- head(res, showCategory)
    gR <- c()
    for(i in 1:nrow(res))
    {
      gR1 <- as.numeric(strsplit(res$GeneRatio[i], split = "/")[[1]][1])
      gR2 <- as.numeric(strsplit(res$GeneRatio[i], split = "/")[[1]][2])
      gR[i] <- gR1/gR2
    }
    res$gR <- gR
    
    if (type == "circle") {
        pt <- ggplot(res, aes(x = .data[["Description"]], y = .data[["gR"]]), 
            colour = .data[["gR"]]) + geom_bar(aes(fill = .data[["gR"]], 
            alpha = .data[["qvalue"]]), stat = "identity", position = "stack") + 
            coord_polar(clip = "off") + theme_minimal() + theme(axis.title.x = element_blank(), 
            axis.title.y = element_blank(), axis.text.y = element_blank(), 
            axis.text.x = element_text(color = "grey20", size = 8, hjust = 0.5, 
                vjust = 0.5, face = "plain"), legend.position = "bottom") + 
            labs(fill = "enrichmentRatio", alpha = "FDR")
    } else if (type == "bar") {
        positions <- res[order(res[["gR"]], decreasing = FALSE), 
            "Description"]
        pt <- ggplot(data = res, aes(x = .data[["Description"]], y = .data[["gR"]])) + 
            geom_bar(stat = "identity", aes(fill = .data[["qvalue"]])) + coord_flip() + 
            theme_bw() + scale_x_discrete(limits = positions) + scale_fill_gradient(low = "#F4B41A", 
            high = "#143D59", trans = "reverse") + labs(fill = "FDR", y = "Gene Ratio")
    } else if (type == "dot") {
        positions <- res[order(res[["gR"]], decreasing = FALSE), 
            "Description"]
        pt <- ggplot(res, aes(x = .data[["Description"]], y = .data[["gR"]], 
            size = .data[["Count"]], color = .data[["qvalue"]])) + geom_point(alpha = 0.8) + 
            theme_bw() + scale_color_gradient(low = "#F4B41A", high = "#143D59", 
            trans = "reverse") + scale_x_discrete(limits = positions) + 
            coord_flip() +
            labs(color = "FDR", size = "Count", y = "Gene Ratio")# + scale_size_continuous(range = range(res[["overlap"]]))
    }
    return(pt)
}

```

# Comparison of enriched TFs in HKCCvsCC and CL075vsCtrl using ChEA3

In the program ChEA3 "TF enrichment analysis (TFEA) prioritizes transcription factors based on the overlap between given lists of differentially expressed genes, and previously annotated TF targets assembled from multiple resources."\n
The goal of ChEA3 is to predict transcription factors (TFs) associated with user-input sets of genes. Discrete query gene sets are compared to ChEA3 libraries of TF target gene sets assembled from multiple orthogonal 'omics' datasets. The Fisher's Exact Test, with a background size of 20,000, is used to compare the input gene set to the TF target gene sets in order to determine which TFs may be most closely associated with the input gene set.

Guide: [ChEA3](https://maayanlab.cloud/chea3/)
```{r chea3, fig.width=8, fig.height=7}

load("BulkRNA_CountAnalysis.RData")
HKvCC_DE_tab <- tr.HKCCvsCC$table
.rowNamesDF(HKvCC_DE_tab, make.names = T) <- tr.HKCCvsCC$genes$Symbol
HKvCC_DE_tab <- HKvCC_DE_tab %>% 
  mutate(Symbol = rownames(.))
# HKvCC_DE_tab_ord <- HKvCC_DE_tab[order(HKvCC_DE_tab$PValue),]
# write.csv(HKvCC_DE_tab_ord, "HKvCC_DE_tab_ord.csv", row.names = T, quote = F)

CL075vctrl_DE_tab <- tr.CL075vsctrl$table
.rowNamesDF(CL075vctrl_DE_tab, make.names = T) <- tr.CL075vsctrl$genes$Symbol
CL075vctrl_DE_tab <- CL075vctrl_DE_tab %>% 
  mutate(Symbol = rownames(.))
# CL075vctrl_DE_tab_ord <- CL075vctrl_DE_tab[order(CL075vctrl_DE_tab$PValue),]
# write.csv(CL075vctrl_DE_tab_ord, "CL075vctrl_DE_tab_ord.csv", row.names = T, quote = F)

my_chea3 <- function(tr.object, name)
{
  DE_tab <- tr.object$table #%>% 
    #filter(logFC > 1)
  .rowNamesDF(DE_tab, make.names = T) <- tr.object$genes$Symbol
  DE_tab_ord <- DE_tab[order(DE_tab$PValue),]
  
  #Add genes to Input_Genes list
  genes <- DE_tab_ord %>%
    mutate(FDR = p.adjust(PValue, method = "BH")) %>% 
    dplyr::filter(FDR <= 0.1 & abs(logFC) > 1) %>% 
    rownames(.)
  #rownames(DE_tab_ord)[1:200]
  
  # Assign variables for ChEA3
  url = "https://amp.pharm.mssm.edu/chea3/api/enrich/"
  encode = "json"
  payload = list(query_name = name, gene_set = genes)
  
  #POST to ChEA3 server
  response = POST(url = url, body = payload, encode = encode)
  json = content(response, "text")
  
  #select mean rank table from results 
  results = fromJSON(json)
  
  mean_rank_tb <- results$`Integrated--meanRank` %>% as_tibble()
  mean_rank_tb[[paste(name)]] = as.numeric(mean_rank_tb$Score)
  mean_rank_tb[[paste(name, "rank", collapse = "_")]] = as.numeric(mean_rank_tb$Rank)
  mean_rank_clean = mean_rank_tb %>%
    dplyr::select(TF,name, ends_with("rank")) %>%
    dplyr::select(-Rank)

  return(mean_rank_clean)
  #return(results)
}
HKvCCmean_rank_clean <- my_chea3(tr.HKCCvsCC, "HKvCC")
HK <- HKvCCmean_rank_clean$`Integrated--meanRank` %>%
  filter(Rank %in% (1:163)) %>%
  separate_rows(Overlapping_Genes) %>%
  dplyr::select(Rank, Score, TF, Overlapping_Genes) %>%
  rename(gene1 = TF, gene2 = Overlapping_Genes)
  
CL075vctrlmean_rank_clean <- my_chea3(tr.CL075vsctrl, "CL075vctrl")
CL <- CL075vctrlmean_rank_clean$`Integrated--meanRank` %>%
  filter(Rank %in% (1:163)) %>%
  separate_rows(Overlapping_Genes) %>%
  dplyr::select(Rank, Score, TF, Overlapping_Genes) %>%
  rename(gene1 = TF, gene2 = Overlapping_Genes)

saveRDS(HKvCCmean_rank_clean, "HKvCCmean_rank_clean_chea3.rds")
saveRDS(CL075vctrlmean_rank_clean, "CL075vctrlmean_rank_clean_chea3.rds")
HKvCCmean_rank_clean <- readRDS("HKvCCmean_rank_clean_chea3.rds")
CL075vctrlmean_rank_clean <- readRDS("CL075vctrlmean_rank_clean_chea3.rds")
# arranged according to rank of first object
combined_TFs <- inner_join(HKvCCmean_rank_clean[1:200,], CL075vctrlmean_rank_clean[1:200,]) %>% 
  column_to_rownames("TF") %>% 
  arrange("HKvsCC rank", "CL075vsctrl rank")
mat = combined_TFs[1:50, c("HKvCC rank", "CL075vctrl rank")]

# get p-values for TFs in mat
mat_pval <- mat %>% 
  tibble::rownames_to_column("Symbol") %>% 
  left_join(., HKvCC_DE_tab[,c("Symbol", "logFC", "PValue")]) %>% 
  rename(logFC.HKvCC = logFC, PValue.HKvCC = PValue) %>% 
  left_join(., CL075vctrl_DE_tab[,c("Symbol", "logFC", "PValue")]) %>% 
  rename(logFC.CL075vctrl = logFC, PValue.CL075vctrl = PValue)

#saveRDS(mat_pval, "commonTF_rank_logFC_pval.rds")

# hclust for genes and their pvals
mat_pval_hclust <- mat_pval %>% 
  dplyr::select(Symbol, PValue.CL075vctrl, PValue.HKvCC) %>% 
  column_to_rownames("Symbol")

mat <- mat_pval %>% 
  select(Symbol, `CL075vctrl rank`, `HKvCC rank`) %>% 
  column_to_rownames("Symbol")

mat_pval_hclust_ <- hclust(dist(mat_pval_hclust))
gene_dend <- as.dendrogram(mat_pval_hclust_)
plot(gene_dend)
#gene_dend = dendextend::rotate(gene_dend,1:50)

cluster_rows = gene_dend

#cluster_rows is of class dendrogram as required by the function
class(cluster_rows)

hkvcc_pval <- mat_pval_hclust$PValue.HKvCC
cl075vctrl_pval <- mat_pval_hclust$PValue.CL075vctrl

ha_hkvcc <- rowAnnotation(pval.hkvcc = 
  anno_barplot(-log10(hkvcc_pval), border = F,
        width = unit(1.5, "cm"), axis_param = list(direction = "reverse"),
        gp = gpar(fill = "#46327e", lty = "blank", col = "white"))
)

ha_cl075vctrl <- rowAnnotation(pval.cl075vctrl = 
  anno_barplot(-log10(cl075vctrl_pval), border = F,
        width = unit(1.5, "cm"), axis_param = list(direction = "reverse"),
        gp = gpar(fill = "#46327e", lty = "blank", col = "white"))
)

p <- Heatmap(mat,
             col = rev(viridis_pal(option = "B")(8)),
             cell_fun = function(j, i, x, y, w, h, fill) {
    if(mat_pval_hclust[i, j] <= 0.0001) {
        grid.text("***", x, y)
    } else if(mat_pval_hclust[i, j] <= 0.001) {
        grid.text("**", x, y)
    }  else if(mat_pval_hclust[i, j] <= 0.01) {
        grid.text("*", x, y)
   
}},
        rect_gp = gpar(col = "white", lwd = 0.5),
        width = ncol(mat)*unit(7, "mm"),
        height = nrow(mat)*unit(1.7, "mm"),
        name = "TFEA rank",
        heatmap_legend_param = list(legend_gp = gpar(fontsize = 5)),
        cluster_rows = cluster_rows, 
        cluster_columns = F,
        show_row_dend = T, 
        show_row_names = T,
        column_title = "Enriched TF rank",
        column_title_gp = gpar(fontsize = 12),
        column_names_gp = gpar(fontsize = 8),
        column_names_rot = 45,
        row_names_gp = gpar(fontsize = 5))

draw(p)
# total <- ha_cl075vctrl + p + ha_hkvcc
# draw(total, merge_legends = TRUE, heatmap_legend_side = "right")

# is_sig_0.01 = hkvcc_pval <= 0.01
# is_sig_0.001 = hkvcc_pval <= 0.001
# is_sig_0.0001 = hkvcc_pval <= 0.0001
# 
# hkvcc_pval_pch <- data.frame(hkvcc = hkvcc)
# pch = rep("*", length(annotation$FDR))
# pch[!is_sig_0.01] <- NA
# 
#  row_annot_padj <- rowAnnotation(FDR = anno_simple(annotation$FDR,
#                                             col = colorRamp2(c(0, 0.5, 1), c("#22A884FF", "#7AD151FF", "#FDE725FF")),
#         pch = pch,
#         gp = gpar(fontsize = 1)))
# 
#       lgd_pvalue = Legend(title = "FDR", col_fun = colorRamp2(c(0, 0.5, 1), c("#22A884FF", "#7AD151FF", "#FDE725FF")), 
#                         at = c(0, 0.5, 1), labels = c("0.01", "0.1","1.0"), title_gp = gpar(fontsize = 10))
#     lgd_sig = Legend(pch = "*", type = "points", labels = "< 0.05", title_gp = gpar(fontsize = 6))
    
pdf("commonTF_HKvCC_CL075vCtrl_pval_clustering_stars.pdf")
draw(p)
dev.off()


# combined_TFs <- full_join(HKvCCmean_rank_clean[1:20,], CL075vctrlmean_rank_clean[1:20,]) %>% 
#   column_to_rownames("TF") %>% 
#   arrange("HKvsCC rank", "CL075vsctrl rank")
# mat_ = as.matrix(combined_TFs[, c("HKvCC rank", "CL075vctrl rank")])
# p <- Heatmap(mat_, 
#              col = viridis_pal(option = "B")(8),
#               rect_gp = gpar(col = "white", lwd = 0.5),
#               width = ncol(mat_)*unit(7, "mm"), 
#               height = nrow(mat_)*unit(3, "mm"),
#               name = "TFEA rank",
#               heatmap_legend_param = list(legend_gp = gpar(fontsize = 5)),
#               cluster_rows = F, cluster_columns = F, # can't measure dist cluster because one column has NA
#               show_row_dend = F, show_row_names = T,
#               column_title = "Enriched TF rank",
#               column_title_gp = gpar(fontsize = 12),
#               column_names_gp = gpar(fontsize = 8),
#               column_names_rot = 45,
#               row_names_gp = gpar(fontsize = 7),
#              na_col = "grey")
# 
# svg("commonTF_union_HKvCC_CL075vCtrl.svg")
# draw(p)
# dev.off()
```

# Differential expression of TFs and target genes using Regulatory Impact Factors (RIF) and Partial Correlation and Information Theory analysis (PCIT)

"The PCIT algorithm identifies meaningful correlations to define edges in a weighted network and can be applied to any correlation-based network including but not limited to gene co-expression networks, while the RIF algorithm identify critical transcript factors (TF) from gene expression data.

These two algorithms when combined provide a very relevant layer of information for gene expression studies"\n

User manual and some theory behind package [CeTF](http://bioconductor.org/packages/release/bioc/vignettes/CeTF/inst/doc/CeTF.html)

The relationship between Average Expression or log(baseMean) and Difference of Expression or log2FoldChange
```{r load data}

data <- read.csv("../Results/gene_counts/P1255_genecounts.csv", row.names=1, sep=";")

# clean the column names
colnames(data) <- sapply(colnames(data), function(x) strsplit(x, split= "Aligned")[[1]][1])
colnames(data) <- gsub("\\.", "_", colnames(data))
colnames(data) <- gsub("X", "", colnames(data))

# data <- data %>% 
#   dplyr::select(contains("HKCC"), contains("CC"))

group = substr(colnames(data), 4, nchar(colnames(data)))

# create DGEList
y <- DGEList(counts = data, group = group)
#remove .x from geneID
rownames(y) <- sapply(rownames(y), 
                                 function(x) strsplit(x, split = "\\.")[[1]][1])


# get gene smybols
#VERY IMPORTANT: y$genes should be a data frame, otherwise glmQLFTest or glmTreat doesn't work
y$genes <- data.frame(ENSEMBL = rownames(y),
                      Symbol = mapIds(org.Hs.eg.db, rownames(y), keytype="ENSEMBL", column="SYMBOL"))
#rownames(y$counts) <- y$genes$Symbol

group_mat <- data.frame(group = y$samples$group)
rownames(group_mat) <- rownames(y$samples)
colnames(group_mat) <- "cond"

# The next part is not required because expDiff does it by itself using Reverter
# filter genes without "worthwhile" counts in minimum two samples
keep <- filterByExpr(y)
# # 
# # # keep only protein coding genes
ensembl <- useEnsembl("ensembl",dataset="hsapiens_gene_ensembl") #,host="https://uswest.ensembl.org"
my.genes <- rownames(y)
out <- getBM(attributes=c("ensembl_gene_id", "gene_biotype"),
     filters="ensembl_gene_id", values=my.genes, mart=ensembl)
out <- out[match(my.genes, out$ensembl_gene_id),]
#
#
keep <- keep & (out$gene_biotype=="protein_coding" & !is.na(out$gene_biotype))
#
y <- y[keep, , keep.lib.sizes=FALSE]
#genes went down from 61857 to 12029!!
y <- calcNormFactors(y)
rownames(y$counts) <- y$genes$Symbol
normalized_counts <- t(cpm(y, prior.count=2, log=T))
```

```{r vars}
diffMethod = "Reverter"
cond1 <- "HKCC"
cond2 <- "CC"
```

```{r PCIT, echo = F, eval = F}

DEGenes <- expDiff(exp = y$counts,
                   anno = group_mat,
                   conditions = c(cond1, cond2),
                   lfc = 1.0,
                   padj = 0.1, 
                   diffMethod = "Reverter")

# Selecting only DE genes from counts data
counts <- y$counts[as.numeric(rownames(DEGenes$DE_unique)), ]

# Converting count data to TPM
tpm <- apply(counts, 2, function(x) {
            (1e+06 * x)/sum(x)
        })

# Count normalization
PCIT_input <- normExp(tpm)

# PCIT input for untrt
PCIT_input_cond1 <- PCIT_input[,grep(paste0("_", cond1, collapse = ""), colnames(PCIT_input))]

# PCIT input for trt
PCIT_input_cond2 <- PCIT_input[,grep(paste0("_", cond2, collapse = ""), colnames(PCIT_input))]

# Performing PCIT analysis for untrt condition
PCIT_out_cond1 <- PCIT(PCIT_input_cond1, tolType = "mean")

# Performing PCIT analysis for trt condition
PCIT_out_cond2 <- PCIT(PCIT_input_cond2, tolType = "mean")

# Printing first 10 rows for untrt condition
kable(PCIT_out_cond1$tab[1:10, ]) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Printing first 10 rows for trt condition
kable(PCIT_out_cond2$tab[1:10, ]) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r qc_vis, fig.dim = c(10,8), echo = F, eval = F}
# Histogram of connectivity distribution

# After performing the PCIT analysis, it is possible to verify the histogram distribution of the clustering coefficient of the adjacency matrix with the significant values
my_histPlot(PCIT_out_cond1$adj_sig)
my_histPlot(PCIT_out_cond2$adj_sig)

# Density Plot of raw correlation and significant PCIT
my_densityPlot(mat1 = PCIT_out_cond2$adj_raw, 
           mat2 = PCIT_out_cond2$adj_sig, 
           threshold = 0.5)

my_densityPlot(mat1 = PCIT_out_cond1$adj_raw, 
           mat2 = PCIT_out_cond1$adj_sig, 
           threshold = 0.5)
```

```{r RIF, echo = F, eval = F}

DEGenes <- expDiff(exp = y$counts,
                   anno = group_mat,
                   conditions = c(cond1, cond2),
                   lfc = 1.0,
                   padj = 0.1, # for TFs, these threshold need not be exactly the same as all genes
                   diffMethod = "Reverter")

# Selecting only DE genes from counts data
counts <- y$counts[as.numeric(rownames(DEGenes$DE_unique)), ]

# Converting count data to TPM
tpm <- apply(counts, 2, function(x) {
            (1e+06 * x)/sum(x)
        })

# Count normalization
Clean_Dat <- normExp(tpm)

# Loading the Transcript Factors (TFs) character
data("TFs")

# Verifying which TFs are in the subsetted normalized data
TFs <- rownames(Clean_Dat)[rownames(Clean_Dat) %in% TFs]

# Selecting the Target genes
Target <- setdiff(rownames(Clean_Dat), TFs)

# Ordering rows of normalized count data
RIF_input <- Clean_Dat[c(Target, TFs), c("01_CC", "02_CC", "03_CC", "04_CC",
                                         "01_HKCC", "02_HKCC", "03_HKCC", "04_HKCC")]

RIF_input <- Clean_Dat[c(Target, TFs), c("01_ctrl", "02_ctrl", "03_ctrl", "04_ctrl",
                                         "01_CL075", "02_CL075", "03_CL075", "04_CL075")]

# Performing RIF analysis
RIF_out <- RIF(input = RIF_input,
               nta = length(Target),
               ntf = length(TFs),
               nSamples1 = 4,
               nSamples2 = 4)

RIF_TF_EnsToSym <- data.frame(ens = RIF_out$TF, 
                     Symbol = mapIds(org.Hs.eg.db, RIF_out$TF, 
                                     keytype="ENSEMBL", column="SYMBOL"))
HKCCvCC_RIF <- RIF_TF_EnsToSym
CL075vctrl_RIF <- RIF_TF_EnsToSym

#RIF_ChEA3_intersect <- intersect(RIF_TF_EnsToSym$Symbol, HK$TF)

RIF_ChEA3_intersect <- inner_join(RIF_TF_EnsToSym, HK, by = c("Symbol" = "gene1")) %>% 
  rename(TF = Symbol)
# Printing first 10 rows
# kable(RIF_out[1:10, ]) %>% 
#   kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

```{r whole_ana}

# these dumb steps are necessary, otherwise runAnalysis can't match the colnames
counts_exp <- y$counts
colnames(counts_exp) <- paste(colnames(counts_exp), group_mat$cond, sep = "_")
anno = group_mat

counts_exp_comparison <- counts_exp %>% 
  as.data.frame() %>% 
  dplyr::select(ends_with(paste0("_",cond1,collapse = "")), 
                ends_with(paste0("_",cond2,collapse = "")))

#
# trying out with gene symbols
# rownames(counts_exp_comparison) <- y$genes$Symbol
.rowNamesDF(counts_exp_comparison, make.names = T) <- y$genes$Symbol
data("TFs")
TF_sym <- data.frame(ens = TFs, 
                     Symbol = mapIds(org.Hs.eg.db, TFs, 
                                     keytype="ENSEMBL", column="SYMBOL"))
out <- runAnalysis(mat = as.matrix(counts_exp_comparison), 
                   conditions=c(cond1, cond2),
                   #lfc = 1.5,
                   padj = 0.1,
                   TFs = TF_sym$Symbol,
                   nSamples1 = 4,
                   nSamples2= 4,
                   tolType = "mean",
                   diffMethod = diffMethod, 
                   data.type = "counts")

```

```{r vis}
# Using the runAnalysis output (CeTF class object)
SmearPlot(object = out, 
          diffMethod = diffMethod, 
          lfc = 1.5, 
          conditions = c(cond1, cond2), 
          type = "DE")

# to vis a specific TF:
SmearPlot(object = out,
          diffMethod = diffMethod,
          lfc = 1.5,
          conditions = c(cond1, cond2),
          TF = 'IRF5', # put TF ID here
          label = TRUE,
          type = "TF")
```

# Gene co-expression network analysis for the two experimental conditions

Key TFs in gene co-expression networks

```{r}
# kable(out@Network@data@listData[["keyTF"]][c("TF", "avgexpr", "freq.diff")], booktabs = T, longtable = T) %>% 
#   kable_styling(latex_options = c("hold_position", "repeat_header"), full_width = F)
paged_table(out@Network@data@listData[["keyTF"]])# [c("TF", "avgexpr", "freq.diff")]
```

Freq.condition1 refers to the number of times the TF was significantly correlated with other genes in that condition. Freq.diff is the difference between significant correlation in one condition vs the other.

<!-- ```{r} -->
<!-- my_netConditionsPlot(out) -->
<!-- ``` -->

# GO enrichment analysis and networks with TFs
Unless otherwise mentioned, red -> gene, blue -> TF

```{r vis_enrich, fig.height = 6, fig.width = 8}
# Accessing the network for condition 1
genes1 <- unique(c(as.character(NetworkData(out, "network1")[, "gene1"]), 
                  as.character(NetworkData(out, "network1")[, "gene2"])))

# Performing getGroupGO analysis
# no statistical power here
# cond1 <- getGroupGO(genes = genes, 
#                     ont = "BP", 
#                     keyType = "ENSEMBL", 
#                     annoPkg = org.Hs.eg.db, 
#                     level = 3)

# # Performing getGroupGO analysis
# cond2 <- getGroupGO(genes = genes2, 
#                     ont = "BP", 
#                     keyType = "ENSEMBL", 
#                     annoPkg = org.Hs.eg.db, 
#                     level = 3)

# Performing getEnrich analysis
enrich1 <- getEnrich(genes = genes1, organismDB = org.Hs.eg.db, 
                    keyType = 'SYMBOL', ont = 'BP', fdrMethod = "BH", 
                    fdrThr = 0.05, minGSSize = 5, maxGSSize = 500)
# # Subsetting only the first 12 Ontologies with more counts
t1 <- head(enrich1$results, 12)

t1[,c("ID", "Description", "p.adjust")]
# Subsetting the network for the conditions to make available only the 12 nodes subsetted
t2 <- subset(enrich1$netGO, enrich1$netGO$gene1 %in% as.character(t1[, "ID"]))

# # generating the GO plot grouping by pathways
pt <- my_netGOTFPlot(netCond = NetworkData(out, "network1") %>%
                    mutate(across(everything(), as.character)),
                  resultsGO = t1,
                  netGO = t2,
                  anno = NetworkData(out, "annotation"),
                  groupBy = 'pathways',
                  type = 'GO')
pt$plot
# 
# head(pt$tab$`GO:0006807`)

# generating the GO plot grouping by TFs
TFs <- NetworkData(out, "keytfs")$TF[1:4]
pt <- my_netGOTFPlot(netCond = NetworkData(out, "network1"),
                  resultsGO = t1,
                  netGO = t2,
                  anno = NetworkData(out, "annotation"),
                  groupBy = 'TFs',
                  TFs = TF_sym$Symbol, 
                  type = 'GO',
                  size = 3)
pt$plot

# generating the GO plot grouping by specifics genes
# genes <- c('ENSG00000011465', 'ENSG00000026025', 'ENSG00000075624', 'ENSG00000077942')
# pt <- netGOTFPlot(netCond = NetworkData(out, "network1"),
#                   resultsGO = t1,
#                   netGO = t2,
#                   anno = NetworkData(out, "annotation"),
#                   groupBy = 'genes',
#                   genes = genes,
#                   type = 'GO')
# pt$plot

# pt <- my_netGOTFPlot(netCond = NetworkData(out, "network1") %>% 
#                    mutate(across(everything(), as.character)),
#                   netGO = t2,
#                   keyTFs = NetworkData(out, "keytfs"), 
#                   type = 'Integrated')
# 
# pt$plot

# my_heatPlot(res = enrich1$results, showCategory = 5,
#          diff = getDE(out, "all"))
my_enrichPlot(res = enrich1$results, showCategory = 20,
           type = "dot")
```

```{r}
# get the netwroks net1 and net2 together for HKCC vs CC
HKvCC_net <- rbind(out@Network@data@listData[["net_cond1"]], out@Network@data@listData[["net_cond2"]]) %>% 
  distinct(gene1, gene2, .keep_all = T)

# Common between CeTF result and ChEA3 result
common_interactions_fwd <- inner_join(HKvCC_net, HK)
common_interactions_rev <- inner_join(HKvCC_net, HK, by = c("gene1" = "gene2", "gene2" = "gene1"))

common_interactions <- rbind(common_interactions_fwd, common_interactions_rev) %>% 
  distinct(gene1, gene2, .keep_all = T)
```


```{r WGCNA}
# WGCNA
#https://alexslemonade.github.io/refinebio-examples/04-advanced-topics/network-analysis_rnaseq_01_wgcna.html
#https://kasperdanielhansen.github.io/genbioconductor/html/Count_Based_RNAseq.html

# DEseq2 to normalise counts

#load("HumanMacrophage_BulkRNA_TFenrichment.RData")

data <- read.csv("../Results/gene_counts/P1255_genecounts.csv", row.names=1, sep=";")

# clean the column names
colnames(data) <- sapply(colnames(data), function(x) strsplit(x, split= "Aligned")[[1]][1])
colnames(data) <- gsub("\\.", "_", colnames(data))
colnames(data) <- gsub("X", "", colnames(data))

# data <- data %>% 
#   dplyr::select(contains("HKCC"), contains("CC"))

groups = data.frame(group = unlist(substr(colnames(data), 4, nchar(colnames(data)))))
rownames(groups) <- colnames(data)
# group_mat <- data.frame(group = y$samples$group)
# rownames(group_mat) <- rownames(y$samples)
# groups <- group_mat %>%
#   dplyr::filter(stringr::str_detect(group, "HKCC") | stringr::str_detect(group, "CC"))

# The next DESeq2 functions need the values to be converted to integers
data <- round(data) %>%
  # The next steps require a data frame and round() returns a matrix
  as.data.frame() %>%
  # Only keep rows that have total counts above the cutoff
  dplyr::filter(rowSums(.) >= 50) 

rownames(data) <- sapply(rownames(data),
                                 function(x) strsplit(x, split = "\\.")[[1]][1])

my.genes <- rownames(data)
ensembl <- useMart(biomart="ensembl",dataset="hsapiens_gene_ensembl")
out <- getBM(attributes=c("ensembl_gene_id", "gene_biotype"), 
    filters="ensembl_gene_id", values=my.genes, mart=ensembl)

mart <- useMart("ensembl")
datasets <- listDatasets(mart)
mart <- useDataset("hsapiens_gene_ensembl",mart)
getBM(attributes = c("affy_hg_u95av2", "hgnc_symbol", "chromosome_name", "band"),
      filters    = "affy_hg_u95av2",
      values     = c("1939_at","1503_at","1454_at"), 
      mart       = mart)
# rows are sorted by `affy_hg_u95av2`, and in different order than the `values` argument

out <- out[match(my.genes, out$ensembl_gene_id),]

data <- data %>% 
  tibble::rownames_to_column("ensembl_gene_id") %>% 
  left_join(., out) %>% 
  dplyr::filter(gene_biotype == "protein_coding") %>% 
  dplyr::select(-gene_biotype) %>% 
  tibble::column_to_rownames("ensembl_gene_id")

rownames.data <- mapIds(org.Hs.eg.db, rownames(data), 
                                     keytype="ENSEMBL", column="SYMBOL")

rownames(data) <- make.names(rownames.data, unique = TRUE)

data <- data[,rownames(groups)]

# Create a `DESeqDataSet` object
dds <- DESeqDataSetFromMatrix(
  countData = data, # Our prepped data frame with counts
  colData = groups, # Data frame with annotation for our samples
  design = model.matrix(~groups$group) # Here we are not specifying a model
)

# Normalize and transform the data in the `DESeqDataSet` object using the `vst()`
# function from the `DESEq2` R package
dds_norm <- vst(dds)

# Retrieve the normalized data from the `DESeqDataSet`
normalized_counts <- assay(dds_norm) %>%
  t() # Transpose this data

# Determine parameters for WGCNA
sft <- pickSoftThreshold(normalized_counts,
  dataIsExpr = TRUE,
  corFnc = cor,
  networkType = "signed",
  verbose = 5
)

sft_df <- data.frame(sft$fitIndices) %>%
  dplyr::mutate(model_fit = -sign(slope) * SFT.R.sq)

ggplot(sft_df, aes(x = Power, y = model_fit, label = Power)) +
  # Plot the points
  geom_point() +
  # We'll put the Power labels slightly above the data points
  geom_text(nudge_y = 0.1) +
  # We will plot what WGCNA recommends as an R^2 cutoff
  geom_hline(yintercept = 0.80, col = "red") +
  # Just in case our values are low, we want to make sure we can still see the 0.80 level
  ylim(c(min(sft_df$model_fit), 1.05)) +
  # We can add more sensible labels for our axis
  xlab("Soft Threshold (power)") +
  ylab("Scale Free Topology Model Fit, signed R^2") +
  ggtitle("Scale independence") +
  # This adds some nicer aesthetics to our plot
  theme_classic()
save.image("DESEQ_for_WGCNA.rds")
```


```{r}
power = 12
# run WGCNA to compute modules
net <- WGCNA::blockwiseModules(normalized_counts,
  maxBlockSize = 5000, # What size chunks (how many genes) the calculations should be run in
  TOMType = "signed", # topological overlap matrix
  power = power, # soft threshold for network construction
  numericLabels = TRUE, # Let's use numbers instead of colors for module labels
  randomSeed = 1234, # there's some randomness associated with this calculation
  # so we should set a seed
  # saveTOMFileBase = "humanMacrophageTOM",
  verbose = 3
)

## if blockwiseModules fails, get the dropdpwn menu of Session and restart R.
## Then library(WGCNA) and run blockwise Modules again

# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```

```{r}
# Get Module Eigengenes per cluster
normalized_counts_ <- normalized_counts %>% 
  t() %>% 
  as.data.frame() %>% 
  # dplyr::select(contains("HKCC") | contains("CC")) %>% 
  dplyr::relocate(contains("HKCC"), contains("CC"), contains("CL075"), contains("ctrl")) %>% 
  t()
MEs0 <- moduleEigengenes(normalized_counts_, mergedColors)$eigengenes
#, mergedColors
# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

h <- Heatmap(t(MEs0),
        cluster_columns = F,
        #height = 4*unit(5, "mm"),
        row_names_gp = gpar(fontsize = 5),
        column_names_gp = gpar(fontsize = 5))
pdf("heatmap_modules_edgeR_logT_p12_allsamples.pdf")
draw(h)
dev.off()
# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  ) %>% 
  mutate(group = str_sub(treatment, start = 4))

mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  facet_wrap(~ group) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```

```{r}
#Run linear model on each module.
net_HK_CC <- net$MEs %>% 
  t() %>% 
  as.data.frame() %>% 
  #dplyr::select(contains("HKCC") | contains("CC")) %>% 
  t()
#Limma wants our tests to be per row, so we also need to transpose so the eigengenes are rows
module_eigengenes <- net_HK_CC
group = substr(rownames(module_eigengenes), 4, nchar(rownames(module_eigengenes)))
## lmFit() needs a transposed version of the matrix
fit <- limma::lmFit(t(module_eigengenes), design = model.matrix(~0+groups$group, ref = "HKCC"))

# Apply empirical Bayes to smooth standard errors
fit <- limma::eBayes(fit)
#
#Apply multiple testing correction and obtain stats in a data frame. 

# Apply multiple testing correction and obtain stats

col_module_num <- data.frame(module = net$colors,
                             col = mergedColors) %>% 
  group_by(module) %>% 
  distinct(module, .keep_all = T) %>% 
  mutate(module = paste("ME", module, sep = ""))
stats_df <- limma::topTable(fit, number = ncol(module_eigengenes)) %>%
  tibble::rownames_to_column("module") %>% 
  left_join(., col_module_num)

modules_up_in_CC_vs_HKCC <- stats_df %>% 
  filter(groups.groupCC > 0 & groups.groupHKCC < 0) %>% 
  filter(adj.P.Val < 0.1)

```


```{r}

# moduleLabels = net$colors
# moduleColors = labels2colors(net$colors)
# MEs = net$MEs;
# geneTree = net$dendrograms[[1]];
# #save(MEs, moduleLabels, moduleColors, geneTree,
# #     file = "humanMacrophage-modules.RData")
# 
# # Recalculate topological overlap if needed
# TOM = TOMsimilarityFromExpr(normalized_counts, power = power);
# # Read in the annotation file
# #annot = read.csv(file = "~/Downloads/FemaleLiver-Data/GeneAnnotation.csv");
# annot = groups
# Select modules
moduleColors_namedvector <- data.frame(colours = mergedColors)
rownames(moduleColors_namedvector) <- names(net$colors)

moduleColors_namedvector_CC_vs_HKCC <- moduleColors_namedvector %>% 
  filter(colours %in% modules_up_in_CC_vs_HKCC$col) %>% 
  rownames_to_column("gene")

modules_TF <- moduleColors_namedvector_CC_vs_HKCC %>% 
  filter(gene %in% rownames(combined_TFs)) %>% 
  pull(colours)

modules_TF_genes <- moduleColors_namedvector_CC_vs_HKCC %>% 
  filter(colours %in% modules_TF)
# modules <- sapply(RIF_ChEA3_intersect$Symbol, 
#                   function(x) moduleColors_namedvector[which(names(moduleColors_namedvector) == x)])

# modules <- sapply(rownames(combined_TFs), 
#                   function(x) moduleColors_namedvector[which(names(moduleColors_namedvector) == x)])
# 
# names(modules) <- sapply(names(modules), function(x) strsplit(x, split = "\\.")[[1]][1])
# Select module probes
norm_counts_modules_TF_genes <- normalized_counts_[,colnames(normalized_counts_) %in% modules_TF_genes$gene]
norm_counts_modules_TF_genes_CC <- norm_counts_modules_TF_genes[grep(pattern = "_CC$", rownames(norm_counts_modules_TF_genes)),]
#TOM = TOMsimilarityFromExpr(norm_counts_modules_TF_genes_CC, power = power, nThreads = 8); 
# cor <- correlatePairs(t(norm_counts_modules_TF_genes_CC), BPPARAM = MulticoreParam(8))
# cor.df <- data.frame(gene1 = cor$gene1,
#                         gene2 = cor$gene2,
#                         rho = cor$rho,
#                         p.value = cor$p.value,
#                         FDR = cor$FDR)
adjacency = adjacency(norm_counts_modules_TF_genes_CC, power = power)
TOM = TOMsimilarity(adjacency);
# probes = colnames(normalized_counts)
# inModule = is.finite(match(moduleColors, modules));
# modProbes = probes[inModule];
# modGenes = modProbes
# 
# modTOM = TOM[inModule, inModule];

dimnames(TOM) = list(colnames(norm_counts_modules_TF_genes_CC), colnames(norm_counts_modules_TF_genes_CC))
write.csv2(TOM, "Cor_matrix_CC_upregulated_modules.csv", row.names = T, quote = F)

TOM_TF <- TOM[,colnames(TOM) %in% rownames(combined_TFs)]
cor.df<- TOM_TF %>% 
  as.data.frame() %>% 
  rownames_to_column("gene1") %>% 
  pivot_longer(!gene1, names_to = "gene2", values_to = "cor") %>% 
  filter(cor != 1) %>% 
  filter(cor != 0) %>% 
  filter(cor >= 0.6)

write.csv2(cor.df, "Cor_df_CC_upregulated_modules.csv", row.names = T, quote = F)

CC_vs_HKCC_DEG_list <- read.csv2("tables/CC_vs_HKCC_DEG_list.csv") %>% 
  rename(gene = Symbol)

nodes.df <- data.frame(gene = c(unique(cor.df$gene1), unique(cor.df$gene2))) %>% 
  mutate(type = case_when(
    gene %in% rownames(combined_TFs) ~ "TF",
    .default = "gene"
  )) %>% 
  left_join(., moduleColors_namedvector_CC_vs_HKCC) %>% 
  left_join(., CC_vs_HKCC_DEG_list[, c("gene", "logFC", "adjusted.pvalue.BH")])

write.csv2(nodes.df, "Nodes_df_CC_upregulated_modules.csv", row.names = F, quote = F)

# modTOM_selected <- modTOM[,c("TRAFD1", "BATF3", "BATF", "IRF5", "IRF2", "STAT2", "GSDMD", "CHMP4A", "CHMP4B")]
# write.csv2(modTOM_selected, "TranscriptionFactor_correlations_CL075_vs_ctrl.csv", row.names = T, quote = F)

```


```{r}

# desired TFs are in "ens" column of RIF_ChEA3_intersect

cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = "EdgeFile_230623.txt",
                               nodeFile = "NodeFile_230623.txt",
                               weighted = TRUE,
                               threshold = 0.25,
                               nodeNames = modProbes,
                               altNodeNames = modGenes,
                               nodeAttr = moduleColors[inModule])

nodes <- read.delim("NodeFile_230623.txt")
edges <- read.delim("EdgeFile_230623.txt")

TFgenes <- RIF_ChEA3_intersect$TF

tablegenes <- tr.HKCCvsCC$table %>% 
  tibble::rownames_to_column("ENSEMBL")

fcgenes <- tr.HKCCvsCC$genes %>%
  tibble::rownames_to_column("ENSEMBL") %>% 
  left_join(tablegenes, .)

nodes <- nodes %>% 
  mutate(type = case_when(
    nodeName %in% TFgenes ~ "TF",
    TRUE ~ "gene"
  )) %>% 
  left_join(., fcgenes, by = c("nodeName" = "Symbol"))

edges <- edges %>% 
  mutate(keepornot = case_when(
    fromNode %in% TFgenes ~ "keep",
    toNode %in% TFgenes ~ "keep",
    TRUE ~ "no"
  )) %>% 
  filter(keepornot == "keep")

write.table(edges, "CytoscapeInput-edges-selected17modules18_0.25.txt", row.names = F, quote = F)
write.table(nodes, "CytoscapeInput-nodes-selected17modules18_0.25.txt", row.names = F, quote = F)

tr.HKCCvsCC.genes <- tr.HKCCvsCC$genes %>% 
  rownames_to_column("ENSEMBL")

tr.HKCCvsCC.table <- tr.HKCCvsCC$table %>% 
  rownames_to_column("ENSEMBL") %>% 
  left_join(., tr.HKCCvsCC.genes)

CytoscapeInput.nodes.selected17modules18_0.25 <- CytoscapeInput.nodes.selected17modules18_0.25 %>%
  as.data.frame() %>% 
  dplyr::select(nodeName, altName, `nodeAttr.nodesPresent...`, type) %>% 
  mutate(Symbol = nodeName) %>% 
  left_join(., tr.HKCCvsCC.table) %>% 
  mutate(FDR = p.adjust(PValue, method = "BH")) %>% 
  mutate(neglog10FDR = -log10(FDR))
## cytoscape group attributes layout based on type
# create filters to pick one TF, etc


save.image("HumanMacrophage_BulkRNA_TFenrichment.RData")

```

<!-- ```{r} -->
<!-- # run VIPER - DoRothEA -->
<!-- BiocManager::install("dorothea") -->
<!-- BiocManager::install("viper") -->
<!-- BiocManager::install("mixtools") -->

<!-- library(dorothea) -->
<!-- library(viper) -->
<!-- library(mixtools) -->

<!-- data(dorothea_hs, package = "dorothea") -->
<!-- hkvcc_samples <- data[,c(grep(pattern = "CC", colnames(data)))] -->

<!-- description = AnnotatedDataFrame(data=group_mat) -->
<!-- ex <- ExpressionSet(assayData = as.matrix(data), phenoData = description) -->

<!-- signature <- rowTtest(ex, "group", "HKCC", "CC") -->
<!-- signature <- (qnorm(signature$p.value/2, lower.tail = FALSE) * sign(signature$statistic))[, 1] -->
<!-- nullmodel <- ttestNull(ex, "group", "HKCC", "CC", per = 1000, repos = TRUE, verbose = FALSE) -->

<!-- mrs <- msviper(signature, regulon, nullmodel, verbose = FALSE) # regulon only has 621 regulators, Bcell related -->
<!-- summary(mrs) -->

<!-- mrshadow <- shadow(mrs, regulators = 25, verbose = FALSE) -->
<!-- ``` -->